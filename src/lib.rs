//!
//! `unimock` is a library that makes it easy to create mock objects that implement _multiple traits_ at the same time.
//!
//! unimock exports a single type, [Unimock], that will implement all your annotated traits:
//!
//! ```rust
//! #![feature(generic_associated_types)]
//! use unimock::*;
//! #[unimock]
//! trait Foo {
//!     fn foo(&self) -> i32;
//! }
//!
//! #[unimock]
//! trait Bar {
//!     fn bar(&self) -> i32;
//! }
//!
//! fn sum(foobar: impl Foo + Bar) -> i32 {
//!     foobar.foo() + foobar.bar()
//! }
//!
//! fn test() {
//!     assert_eq!(
//!         42,
//!         sum(
//!             mock([
//!                 Foo__foo::stub(|each| {
//!                     each.call(matching!()).returns(40);
//!                 }),
//!                 Bar__bar::stub(|each| {
//!                     each.call(matching!()).returns(2);
//!                 })
//!             ])
//!         )
//!     );
//! }
//! ```
//!
//! `unimock` also works with `async_trait`:
//!
//! ```rust
//! #![feature(generic_associated_types)]
//! use unimock::*;
//! use async_trait::*;
//! #[unimock]
//! #[async_trait]
//! trait Baz {
//!     async fn baz(&self, arg: String) -> i32;
//! }
//! ```

#![forbid(unsafe_code)]
// For the mock-fn feature:
#![feature(generic_associated_types)]

/// Types for used for building and defining mock behaviour.
pub mod build;
/// APIs used by macros, not intended to be used directly.
pub mod macro_api;
/// Extra utilities
pub mod util;

mod counter;
mod error;
mod mock;

use std::any::TypeId;
use std::collections::HashMap;
use std::panic::RefUnwindSafe;
use std::sync::atomic::{AtomicBool, AtomicUsize};
use std::sync::{Arc, Mutex};

///
/// Autogenerate mocks for all methods in the annotated traits, and `impl` it for [Unimock].
///
/// Mock generation happens by declaring a new [MockFn]-implementing struct for each method.
///
/// # Example
/// ```rust
/// #![feature(generic_associated_types)]
/// use unimock::*;
///
/// #[unimock]
/// trait Trait1 {
///     fn a(&self) -> i32;
///     fn b(&self) -> i32;
/// }
///
/// #[unimock]
/// trait Trait2 {
///     fn c(&self) -> i32;
/// }
///
/// fn sum(obj: impl Trait1 + Trait2) -> i32 {
///     obj.a() + obj.b() + obj.c()
/// }
///
/// fn test() {
///     // Unimock now implements both traits:
///     sum(mock(None)); // note: panics at runtime!
///
///     // Mock a single method (still panics, because all 3 must be mocked:):
///     sum(mock(Some(Trait1__a::next(|_| true).returns(0).once().in_order())));
/// }
/// ```
pub use unimock_macros::unimock;

///
/// Macro to ease argument pattern matching.
/// This macro produces a closure expression suitable for passing to [build::Each::call].
///
/// Takes inspiration from [std::matches] and works similarly, except that the value to match
/// can be removed as a macro argument, since it is instead received as the closure argument.
///
/// Unimock uses tuples to represent multiple arguments. A single argument is not a tuple.
/// To avoid the extra set of parentheses for simple multi-argument matchers, there is
/// a special syntax that accepts several top-level patterns:
/// `matching!("a", "b")` will expand to `matching!(("a", "b"))`.
///
/// # Example
///
/// ```rust
/// # use unimock::*;
///
/// fn one_str() {
///     fn args(_: impl Fn(&(&str)) -> bool) {}
///     args(matching!("a"));
/// }
///
/// fn three_strs() {
///     fn args(_: impl Fn(&(&str, &str, &str)) -> bool) {}
///     args(matching!("a", _, "c"));
///     args(matching!(("a", "b", "c") | ("d", "e", "f")));
///     args(matching!(("a", b, "c") if b.contains("foo")));
/// }
/// ```
///
/// # Auto-"coercions"
///
/// Since the input expression being matched is generated by the macro, you would
/// normally suffer from the following problem when matching some non-`&str` function input:
///
/// ```compile_fail
/// # fn test() -> bool {
/// let string = String::new();
/// match &string {
///     "foo" => true, // expected struct `String`, found `str`
///     _ => false,
/// # }
/// }
/// ```
///
/// To help ergonomics, the `matching` macro recognizes certain literals used in the
/// patterns, and performs appropriate type conversion at the correct places:
///
/// ```rust
/// # use unimock::*;
/// struct Newtype(String);
///
/// fn exotic_strings() {
///     fn args(_: impl Fn(&(String, std::borrow::Cow<'static, str>, Newtype, i32)) -> bool) {}
///     args(matching!(("a", _, "c", _) | (_, "b", _, 42)));
/// }
///
/// // Newtype works by implementing the following:
/// impl std::convert::AsRef<str> for Newtype {
///     fn as_ref(&self) -> &str {
///         self.0.as_str()
///     }
/// }
/// ```
///
/// Internally it works by calling [macro_api::as_str_ref] on inputs matched by a string literal.
pub use unimock_macros::matching;

#[derive(Clone, Copy)]
enum FallbackMode {
    Error,
    Unmock,
}

/// Unimock's purpose is to be an implementor of downstream traits via mock objects.
/// A single mock object provides the implementation of a single trait method.
///
/// The interaction with these mock objects always happen via the Unimock facade and
/// the traits that it implements.
pub struct Unimock {
    fallback_mode: FallbackMode,
    original_instance: bool,
    state: Arc<SharedState>,
}

struct SharedState {
    impls: HashMap<TypeId, mock::DynImpl>,
    next_call_index: AtomicUsize,
    panic_reasons: Mutex<Vec<error::MockError>>,
}

impl Unimock {
    /// Evaluate a [MockFn] given some inputs, to produce its output.
    /// Any failure will result in panic.
    pub fn eval<'i, F: MockFn + 'static>(&'i self, inputs: F::Inputs<'i>) -> F::Output {
        match mock::eval::<F>(
            self.state.impls.get(&TypeId::of::<F>()),
            inputs,
            &self.state.next_call_index,
            self.fallback_mode,
        ) {
            Ok(macro_api::ConditionalEval::Yes(output)) => output,
            Ok(macro_api::ConditionalEval::No(_)) => panic!(
                "{}",
                self.prepare_panic(error::MockError::CannotUnmock { name: F::NAME })
            ),
            Err(mock_error) => panic!("{}", self.prepare_panic(mock_error)),
        }
    }

    /// Conditionally evaluate a [MockFn] given some inputs.
    /// Unimock conditionally evaluates it based on internal state.
    /// There are two outcomes, either it is evaluated producing the output,
    /// or it stays unevaluated and returns its inputs back to the caller,
    /// with the intention of the caller then _unmocking_ the call.
    pub fn conditional_eval<'i, F: MockFn + 'static>(
        &'i self,
        inputs: F::Inputs<'i>,
    ) -> macro_api::ConditionalEval<'i, F> {
        match mock::eval(
            self.state.impls.get(&TypeId::of::<F>()),
            inputs,
            &self.state.next_call_index,
            self.fallback_mode,
        ) {
            Ok(evaluated) => evaluated,
            Err(mock_error) => panic!("{}", self.prepare_panic(mock_error)),
        }
    }

    fn prepare_panic(&self, error: error::MockError) -> String {
        let msg = error.to_string();

        let mut panic_reasons = self.state.panic_reasons.lock().unwrap();
        panic_reasons.push(error.clone());

        msg
    }
}

impl Clone for Unimock {
    fn clone(&self) -> Unimock {
        Unimock {
            fallback_mode: self.fallback_mode,
            original_instance: false,
            state: self.state.clone(),
        }
    }
}

impl Drop for Unimock {
    fn drop(&mut self) {
        // skip verification if not the original instance.
        if !self.original_instance {
            return;
        }

        // skip verification if already panicking in the original thread.
        if std::thread::panicking() {
            return;
        }

        let strong_count = Arc::strong_count(&self.state);

        if strong_count > 1 {
            panic!("Unimock cannot verify calls, because the original instance got dropped while there are clones still alive.");
        }

        fn panic_if_nonempty(errors: &[error::MockError]) {
            if errors.is_empty() {
                return;
            }

            let error_strings = errors
                .into_iter()
                .map(|err| err.to_string())
                .collect::<Vec<_>>();
            panic!("{}", error_strings.join("/n"));
        }

        {
            // if already panicked, it must be in another thread. Forward that panic to the original thread.
            // (if original is even still in the original thread.. But panic as close to the test "root" as possible)
            let panic_reasons = self.state.panic_reasons.lock().unwrap();
            panic_if_nonempty(&panic_reasons);
        }

        let mut mock_errors = Vec::new();
        for (_, dyn_impl) in self.state.impls.iter() {
            dyn_impl.0.verify(&mut mock_errors);
        }
        panic_if_nonempty(&mock_errors);
    }
}

///
/// The main trait used for unimock configuration.
///
/// `MockFn` describes functional APIs that may be called via dispatch, a.k.a. _Inversion of Control_.
/// Virtuality should be regarded as as test-time virtuality: A virtual function is either the real deal (see [Unmock]) OR it is mocked.
///
/// In Rust, the most convenient way to perform a virtualized/dispatched function call is to
/// call a trait method.
///
/// `MockFn` only provides metadata about an API, it is not directly callable.
///
/// As this is a trait itself, it needs to be implemented to be useful. Methods are not types,
/// so we cannot implement `MockFn` for those. But a surrogate type can be introduced:
///
/// ```rust
/// trait ILoveToMock {
///     fn method(&self);
/// }
///
/// // The method can be referred to via the following empty surrogate struct:
/// struct ILoveToMock__method;
///
/// /* impl MockFn for Mockable_method ... */
/// ```
///
pub trait MockFn: Sized + 'static {
    /// The inputs to the function.
    type Inputs<'i>;

    /// The output of the function.
    type Output;

    /// The number of inputs.
    const N_INPUTS: u8;

    /// The name to use for runtime errors.
    const NAME: &'static str;

    /// Create a stubbing clause.
    ///
    /// A stub sets up call patterns on a single function, that can be matched in any order.
    ///
    /// For exact order verification, reach for [Self::next] instead.
    fn stub<'c, S>(setup: S) -> build::Clause
    where
        for<'i> Self::Inputs<'i>: std::fmt::Debug,
        S: FnOnce(&mut build::Each<Self>) + 'c,
    {
        let mut each = build::Each::new_stub(mock::InputDebugger::new_debug());
        setup(&mut each);
        each.to_clause()
    }

    fn nodebug_stub<'c, S>(setup: S) -> build::Clause
    where
        S: FnOnce(&mut build::Each<Self>) + 'c,
    {
        let mut each = build::Each::new_stub(mock::InputDebugger::new_nodebug());
        setup(&mut each);
        each.to_clause()
    }

    /// Initiate a call pattern builder intended to be used as a [build::Clause]
    /// with exact order verification. The build sequence should end with [build::ExactlyQuantifiedResponse::in_order].
    ///
    /// This differens from [Self::stub], in that that a stub defines all call patterns without any
    /// specific required call order. This function takes only single input matcher, that MUST be
    /// matched in the order specified, relative to other next calls.
    fn next<'c, M>(matching: M) -> build::DefineOutput<'c, Self>
    where
        for<'i> Self::Inputs<'i>: std::fmt::Debug,
        M: (for<'i> Fn(&Self::Inputs<'i>) -> bool) + Send + Sync + RefUnwindSafe + 'static,
    {
        build::DefineOutput::new_standalone(mock::TypedMockImpl::new_standalone_mock(
            mock::InputDebugger::new_debug(),
            Box::new(matching),
        ))
    }
}

/// [MockFn] with the ability to unmock into a unique true implementation.
///
/// A true implementation must be a standalone function, not part of a trait,
/// where the first parameter is generic (a `self`-replacement), and the rest of the parameters are
/// identical to [MockFn::Inputs]:
///
/// ```rust
/// # #![feature(generic_associated_types)]
/// # use unimock::*;
/// #[unimock(unmocked=[my_original])]
/// trait DoubleNumber {
///     fn double_number(&self, a: i32) -> i32;
/// }
///
/// // The true implementation is a regular, generic function which performs number doubling!
/// fn my_original<T>(_: T, a: i32) -> i32 {
///     a * 2
/// }
/// ```
///
/// The unmock feature makes sense when the reason to define a mockable trait
/// is _solely_ for the purpose of inversion-of-control at test-time: Release code
/// need only one way to double a number.
///
/// Standalone functions enables arbitrarily deep integration testing
/// in unimock-based application architectures. When unimock calls the true implementation,
/// it inserts itself as the generic first parameter. When this parameter is
/// bounded by traits, the original `fn` is given capabilities to call other APIs,
/// though only indirectly. Each method invocation happening during a test will invisibly pass
/// through unimock, resulting in a great level of control. Consider:
///
/// ```rust
/// # #![feature(generic_associated_types)]
/// # use unimock::*;
/// #[unimock(unmocked=[my_factorial])]
/// trait Factorial {
///     fn factorial(&self, input: u32) -> u32;
/// }
///
/// // will it eventually panic?
/// fn my_factorial(f: &impl Factorial, input: u32) -> u32 {
///     f.factorial(input - 1) * input
/// }
///
/// assert_eq!(
///     120,
///     // well, not in the test, at least!
///     mock([
///         Factorial__factorial::stub(|each| {
///             each.call(matching!((input) if *input <= 1)).returns(1_u32); // unimock controls the API call
///             each.call(matching!(_)).unmocked();
///         })
///     ])
///     .factorial(5)
/// );
/// ```
///
pub trait Unmock: MockFn {}

/// Construct a unimock instance that works like a mock or a stub, from a set of [build::Clause]es.
///
/// Every call hitting the instance must be declared in advance as an input clause,
/// or else panic will ensue.
#[inline]
pub fn mock<I>(clauses: I) -> Unimock
where
    I: IntoIterator<Item = build::Clause>,
{
    mock_from_iterator(&mut clauses.into_iter(), FallbackMode::Error)
}

/// Construct a unimock instance that works like a spy, where every clause
/// acts as an override over the default behaviour, which is to hit
/// "real world" code using the [Unmock] feature.
///
/// # Example
/// ```rust
/// # #![feature(generic_associated_types)]
/// # use unimock::*;
///
/// #[unimock(unmocked=[real_foo])]
/// trait Trait {
///     fn foo(&self);
/// }
///
/// fn real_foo<T: std::any::Any>(_: &T) {
///     println!("real thing");
/// }
///
/// // Spy objects that spies on nothing:
/// spy(None).foo();
/// spy([]).foo();
/// // prints "real thing" x 2
///
/// spy(Some(Trait__foo::next(matching!()).returns(()).once().in_order())).foo();
/// // does not print
///
/// // spy object that prevents the real
///
/// ```
#[inline]
pub fn spy<I>(clauses: I) -> Unimock
where
    I: IntoIterator<Item = build::Clause>,
{
    mock_from_iterator(&mut clauses.into_iter(), FallbackMode::Unmock)
}

fn mock_from_iterator(
    clause_iterator: &mut dyn Iterator<Item = build::Clause>,
    fallback_mode: FallbackMode,
) -> Unimock {
    let mut assembler = mock::MockAssembler::new();

    for build::Clause(mut dyn_impl) in clause_iterator {
        match dyn_impl.0.assemble_into(&mut assembler) {
            Ok(_) => {}
            Err(error) => panic!("{}", error.to_string()),
        }
    }

    Unimock {
        fallback_mode,
        original_instance: true,
        state: Arc::new(SharedState {
            impls: assembler.impls,
            next_call_index: AtomicUsize::new(0),
            panic_reasons: Mutex::new(vec![]),
        }),
    }
}
