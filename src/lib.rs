//!
//! `unimock` is a library that makes it easy to create mock objects that implement _multiple traits_ at the same time.
//!
//! unimock exports a single type, [Unimock], that will implement all your annotated traits:
//!
//! ```rust
//! #![feature(generic_associated_types)]
//! use unimock::*;
//! #[unimock_next]
//! trait Foo {
//!     fn foo(&self) -> i32;
//! }
//!
//! #[unimock_next]
//! trait Bar {
//!     fn bar(&self) -> i32;
//! }
//!
//! fn sum(foobar: impl Foo + Bar) -> i32 {
//!     foobar.foo() + foobar.bar()
//! }
//!
//! /*
//! fn test() {
//!     let unimock = Unimock::new()
//!         .mock(|foo: &mut MockFoo| {
//!             foo.expect_foo().return_const(40);
//!         })
//!         .mock(|bar: &mut MockBar| {
//!             bar.expect_bar().return_const(2);
//!         });
//!
//!     let answer = sum(unimock);
//!     assert_eq!(42, answer);
//! }
//! */
//!
//! fn test_next() {
//!     assert_eq!(
//!         42,
//!         sum(
//!             mock(Foo__foo, |each| {
//!                 each.call(matching!()).returns(40);
//!             })
//!             .also(Bar__bar, |each| {
//!                 each.call(matching!()).returns(2);
//!             })
//!         )
//!     );
//! }
//! ```
//!
//! `unimock` also works with `async_trait`:
//!
//! ```rust
//! #![feature(generic_associated_types)]
//! use unimock::*;
//! use async_trait::*;
//! #[unimock_next]
//! #[async_trait]
//! trait Baz {
//!     async fn baz(&self, arg: String) -> i32;
//! }
//! ```

#![forbid(unsafe_code)]
// For the mock-fn feature:
#![feature(generic_associated_types)]

/// Various builder-like types for composing mock behaviour on functions.
pub mod builders;

#[doc(hidden)]
pub mod mock;

mod counter;

use std::any::TypeId;
use std::collections::HashMap;
use std::future::Future;
use std::pin::Pin;
use std::sync::atomic::AtomicUsize;

///
/// Autogenerate mocks for all methods in the annotated traits, and `impl` it for [Unimock].
///
/// Mock generation happens by declaring a new [Api]-implementing struct for each method.
///
/// Example
/// ```rust
/// #![feature(generic_associated_types)]
/// use unimock::*;
///
/// #[unimock_next]
/// trait Trait1 {
///     fn a(&self) -> i32;
///     fn b(&self) -> i32;
/// }
///
/// #[unimock_next]
/// trait Trait2 {
///     fn c(&self) -> i32;
/// }
///
/// fn sum(obj: impl Trait1 + Trait2) -> i32 {
///     obj.a() + obj.b() + obj.c()
/// }
///
/// fn test() {
///     let single_mock: Unimock = mock(Trait1__a, |_| {});
///     sum(single_mock); // note: panics at runtime!
/// }
/// ```
pub use unimock_macros::unimock_next;

///
/// Macro to ease argument pattern matching.
/// This macro produces a closure expression suitable for passing to [builders::Each::call].
///
/// Takes inspiration from [std::matches] and works similarly, except that the value to match
/// can be removed as a macro argument, since it is instead received as the closure argument.
///
/// Unimock uses tuples to represent multiple arguments. A single argument is not a tuple.
/// To avoid the extra set of parentheses for simple multi-argument matchers, there is
/// a special syntax that accepts several top-level patterns:
/// `matching!("a", "b")` will expand to `matching!(("a", "b"))`.
///
/// # Example
///
/// ```rust
/// # use unimock::*;
///
/// fn one_str() {
///     fn args(_: impl Fn(&(&str)) -> bool) {}
///     args(matching!("a"));
/// }
///
/// fn three_strs() {
///     fn args(_: impl Fn(&(&str, &str, &str)) -> bool) {}
///     args(matching!("a", _, "c"));
///     args(matching!(("a", "b", "c") | ("d", "e", "f")));
///     args(matching!(("a", b, "c") if b.contains("foo")));
/// }
/// ```
///
/// # Auto-"coercions"
///
/// Since the input expression being matched is generated by the macro, you would
/// normally suffer from the following problem when matching some non-`&str` function input:
///
/// ```compile_fail
/// # fn test() -> bool {
/// let string = String::new();
/// match &string {
///     "foo" => true, // expected struct `String`, found `str`
///     _ => false,
/// # }
/// }
/// ```
///
/// To help ergonomics, the `matching` macro recognizes certain literals used in the
/// patterns, and performs appropriate type conversion at the correct places:
///
/// ```rust
/// # use unimock::*;
/// struct Newtype(String);
///
/// fn exotic_strings() {
///     fn args(_: impl Fn(&(String, std::borrow::Cow<'static, str>, Newtype, i32)) -> bool) {}
///     args(matching!(("a", _, "c", _) | (_, "b", _, 42)));
/// }
///
/// // Newtype works by implementing the following:
/// impl std::convert::AsRef<str> for Newtype {
///     fn as_ref(&self) -> &str {
///         self.0.as_str()
///     }
/// }
/// ```
///
/// Internally it works by calling [as_str_ref] on inputs matched by a string literal.
pub use unimock_macros::matching;

enum FallbackMode {
    Panic,
    CallOriginal,
}

/// Unimock's purpose is to be an implementor of downstream traits via mock objects.
/// A single mock object provides the implementation of a single trait method.
///
/// The interaction with these mock objects always happen via the Unimock facade and
/// the traits that it implements.
pub struct Unimock {
    fallback_mode: FallbackMode,
    impls: HashMap<TypeId, mock::DynImpl>,
}

impl Unimock {
    /// Create a new, empty Unimock. Attempting to call implemented traits on an empty instance will panic at runtime.
    pub fn empty() -> Self {
        Self {
            fallback_mode: FallbackMode::Panic,
            impls: HashMap::new(),
        }
    }

    /// Extend this instance with a mock of another [Api].
    pub fn also<A: Api + 'static>(
        mut self,
        _: A,
        setup: impl FnOnce(&mut builders::Each<A>),
    ) -> Self {
        let mut each = builders::Each::new();
        setup(&mut each);

        self.impls.insert(
            TypeId::of::<A>(),
            mock::DynImpl::Mock(Box::new(mock::MockImpl::from_each(each, mock::Mode::Mock))),
        );
        self
    }

    /// Extend this instance with a spy wrapping another [Api].
    pub fn also_spy<A: Api + 'static>(
        mut self,
        _: A,
        setup: impl FnOnce(&mut builders::Each<A>),
    ) -> Self {
        let mut each = builders::Each::new();
        setup(&mut each);

        self.impls.insert(
            TypeId::of::<A>(),
            mock::DynImpl::Spy(Box::new(mock::MockImpl::from_each(each, mock::Mode::Spy))),
        );
        self
    }

    /// Extend this instance with an instruction to just call the original implementation of the given [Api],
    /// without any mock-related behaviour.
    pub fn also_call<A: Api + 'static>(mut self, _: A) -> Self {
        self.impls.insert(TypeId::of::<A>(), mock::DynImpl::Call);
        self
    }

    /// Change unregistered [Api] fallback behaviour from explicitly panicking to trying to call their original implementation.
    pub fn or_else_call_any(mut self) -> Self {
        self.fallback_mode = FallbackMode::CallOriginal;
        self
    }

    /// Create a unimock that instead of trying to mock, tries to call some original implementation of any API.
    ///
    /// What is considered an original implementation, is not something that unimock concerns itself with,
    /// the behaviour is completely customized for each trait and it is also opt-in.
    ///
    /// If some implementation has no way to call an "original implementation", it should panic.
    ///
    /// A call-original unimock may be `union`ed together with normal mocks, effectively
    /// creating a mix of real and mocked APIs, allowing deeper tests than mock-only mode can provide.
    pub fn call_original() -> Self {
        Self {
            fallback_mode: FallbackMode::CallOriginal,
            impls: HashMap::new(),
        }
    }

    pub(crate) fn with_single_mock(type_id: TypeId, dyn_impl: mock::DynImpl) -> Self {
        Self {
            fallback_mode: FallbackMode::Panic,
            impls: [(type_id, dyn_impl)].into(),
        }
    }

    /// Look up a stored mock object and expose it as a dynamic implementation
    /// of a function. The implementation can be one of two types: A mock and an
    /// instruction to call a real implementation.
    pub fn get_impl<'s, A: Api + 'static>(&'s self) -> mock::Impl<'s, A> {
        self.impls
            .get(&TypeId::of::<A>())
            .map(mock::Impl::from_storage)
            .unwrap_or_else(|| mock::Impl::from_fallback(&self.fallback_mode))
    }
}

///
/// Trait describing some functional API for which unimock may provide implementation.
/// _Inversion of Control_ in Rust is achieved through method dispatch, so the items described
/// will usually be _methods_ in _traits_.
///
/// As `Api` is a trait itself, it needs to be implemented to be useful. Because trait methods
/// are not types, a _surrogate_ need to be introduced:
///
/// ```rust
/// trait Mockable {
///     fn method(&self);
/// }
///
/// // The method can be referred to via the following empty surrogate struct:
/// struct Mockable__method;
///
/// /* impl Api for Mockable_method ... */
/// ```
///
pub trait Api: Sized {
    /// The inputs to the function.
    type Inputs<'i>;

    /// The output of the function.
    type Output;

    /// The number of inputs.
    const N_INPUTS: u8;

    /// The name to use for runtime errors.
    const NAME: &'static str;

    /// Call the Api's real implementation, if any. The default behaviour is just to panic.
    fn call<'i>(_: Self::Inputs<'i>) -> Self::Output {
        panic!(
            "Nothing is implemented for synchronous real call to {}",
            Self::NAME
        )
    }

    /// Call the Api's real implementation, if any, in an async context. The default behaviour is just to panic.
    fn call_async<'i>(_: Self::Inputs<'i>) -> Pin<Box<dyn Future<Output = Self::Output>>> {
        panic!(
            "Nothing is implemented for async real call to {}",
            Self::NAME
        )
    }
}

/// Mock a single [Api].
pub fn mock<A: Api + 'static>(_: A, setup: impl FnOnce(&mut builders::Each<A>)) -> Unimock {
    let mut each = builders::Each::new();
    setup(&mut each);
    Unimock::with_single_mock(
        TypeId::of::<A>(),
        mock::DynImpl::Mock(Box::new(mock::MockImpl::from_each(each, mock::Mode::Mock))),
    )
}

/// Spy on a single [Api].
///
/// A spy performs argument matching and call count verification, but ignores any mock output configuration.
/// Instead, a spy produces the output value by trying to invoke the original implementation of the API.
pub fn spy<A: Api + 'static>(_: A, setup: impl FnOnce(&mut builders::Each<A>)) -> Unimock {
    let mut each = builders::Each::new();
    setup(&mut each);
    Unimock::with_single_mock(
        TypeId::of::<A>(),
        mock::DynImpl::Spy(Box::new(mock::MockImpl::from_each(each, mock::Mode::Spy))),
    )
}

///
/// Internal trait implemented by references that allows transforming from `&T` to `&'static T`
/// by leaking memory.
///
/// The trait is implemented for all `&T`. It allows functions to refer to the non-referenced owned value `T`,
/// and leak that.
///
pub trait LeakOutput {
    type Owned: 'static;

    fn leak(value: Self::Owned) -> Self;
}

impl<T: 'static> LeakOutput for &T {
    type Owned = T;

    fn leak(value: Self::Owned) -> Self {
        Box::leak(Box::new(value))
    }
}

/// Convert any type implementing `AsRef<str>` to a `&str`.
/// Used by [matching].
pub fn as_str_ref<T>(input: &T) -> &str
where
    T: AsRef<str>,
{
    input.as_ref()
}
